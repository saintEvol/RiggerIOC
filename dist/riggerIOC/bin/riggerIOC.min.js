/**
* 一个可以使用协程等待的基类
*/
var riggerIOC;
(function (riggerIOC) {
    var BaseWaitable = /** @class */ (function () {
        function BaseWaitable() {
            // protected mContent: T = null;
            this.mIsDone = false;
            this.mResult = null;
            this.mIsCanceled = false;
            this.mReason = null;
            this.waitingTask = null;
        }
        BaseWaitable.prototype.dispose = function () {
            this.mReason = null;
            this.mResult = null;
            this.mDoneCallback = null;
            this.mCanceledCallback = null;
            this.waitingTask = null;
        };
        /**
         * 任务是否已经完成
        */
        BaseWaitable.prototype.isDone = function () {
            return this.mIsDone;
        };
        /**
         * 是否取消了
        */
        BaseWaitable.prototype.isCanceled = function () {
            return this.mIsCanceled;
        };
        /**
         * 是否正在等待
        */
        BaseWaitable.prototype.isWaitting = function () {
            return this.waitingTask != null;
        };
        /**
         * 开启任务,开启之后，进行等待状态
        */
        BaseWaitable.prototype.startTask = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.mIsDone = false;
            this.mIsCanceled = false;
            this.mResult = null;
            this.mReason = null;
            return this;
        };
        BaseWaitable.prototype.getResult = function () {
            return this.mResult;
        };
        BaseWaitable.prototype.getReason = function () {
            return this.mReason;
        };
        /**
         * 等待任务完成
         * @param args
         */
        BaseWaitable.prototype.wait = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (this.isWaitting())
                return this.waitingTask;
            if (this.mIsDone)
                return this.mResult;
            if (this.mIsCanceled)
                return this.mReason;
            this.waitingTask = riggerIOC.waitFor(this.startTask());
            return this.waitingTask;
        };
        /**
         * 任务完成
        */
        BaseWaitable.prototype.done = function (result) {
            if (result === void 0) { result = null; }
            if (this.mIsDone)
                return;
            if (this.mIsCanceled)
                return;
            this.mIsDone = true;
            this.mResult = result;
            if (this.mDoneCallback) {
                this.mDoneCallback(result);
                this.reset();
            }
            this.mDoneCallback = null;
            this.mCanceledCallback = null;
            this.mIsCanceled = false;
            this.waitingTask = null;
        };
        BaseWaitable.prototype.cancel = function (reason) {
            if (reason === void 0) { reason = null; }
            if (this.mIsCanceled)
                return;
            if (this.mIsDone)
                return;
            this.mIsCanceled = true;
            this.mReason = reason;
            if (this.mCanceledCallback) {
                this.mCanceledCallback(reason);
                this.reset();
            }
            this.mCanceledCallback = null;
            this.mDoneCallback = null;
            this.mIsDone = false;
            this.waitingTask = null;
        };
        BaseWaitable.prototype.reset = function () {
            this.mIsCanceled = false;
            this.mIsDone = false;
            this.mResult = null;
            this.mReason = null;
            this.mCanceledCallback = null;
            this.mDoneCallback = null;
            return this;
        };
        BaseWaitable.prototype.setDoneCallback = function (fun) {
            this.mDoneCallback = fun;
        };
        BaseWaitable.prototype.setCancelCallback = function (act) {
            this.mCanceledCallback = act;
        };
        return BaseWaitable;
    }());
    riggerIOC.BaseWaitable = BaseWaitable;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
///<reference path="../pool/Pool.ts" />
var riggerIOC;
(function (riggerIOC) {
    var Handler = /** @class */ (function () {
        function Handler(caller, func, args, once) {
            if (args === void 0) { args = null; }
            if (once === void 0) { once = false; }
            this._ifOnce = false;
            this._caller = caller;
            this._method = func;
            this._args = args;
            this._ifOnce = once;
        }
        Object.defineProperty(Handler, "pool", {
            get: function () {
                if (!Handler.m_pool)
                    Handler.m_pool = new riggerIOC.Pool();
                return Handler.m_pool;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Handler.prototype, "caller", {
            get: function () {
                return this._caller;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Handler.prototype, "method", {
            get: function () {
                return this._method;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Handler.prototype, "ifOnce", {
            get: function () {
                return this._ifOnce;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Handler.prototype, "args", {
            get: function () {
                return this._args;
            },
            enumerable: true,
            configurable: true
        });
        Handler.prototype.dispose = function () {
            this._caller = null;
            this._method = null;
            this._args = null;
        };
        Handler.create = function (caller, fun, args, once) {
            if (args === void 0) { args = null; }
            if (once === void 0) { once = true; }
            var ret = Handler.pool.getItem(Handler.riggerHandlerSign);
            if (ret) {
                ret._caller = caller;
                ret._method = fun;
                ret._args = args;
                ret._ifOnce = once;
                return ret;
            }
            return new Handler(caller, fun, args, once);
        };
        /**
         * 将一个RiggerHandler回收到对象池
         * @param handler
         */
        Handler.recover = function (handler) {
            handler.dispose();
            Handler.pool.recover(Handler.riggerHandlerSign, handler);
        };
        /**
         * 将自身回收至对象池
         */
        Handler.prototype.recover = function () {
            Handler.recover(this);
        };
        Handler.prototype.once = function () {
            this._ifOnce = true;
        };
        /**
         * 无参执行
         */
        Handler.prototype.run = function () {
            if (this._method) {
                var ret = this._method.apply(this._caller, this._args);
                if (this._ifOnce)
                    this.dispose();
                return ret;
            }
        };
        /**
         * 带参执行
         * @param args
         */
        Handler.prototype.runWith = function (args) {
            if (!args)
                return this.run();
            if (this._method) {
                var ret = void 0;
                if (args) {
                    ret = this._method.apply(this._caller, args.concat(this._args));
                }
                else {
                    ret = this._method.apply(this._caller, this._args);
                }
                if (this._ifOnce)
                    this.dispose();
                return ret;
            }
            return null;
        };
        Handler.riggerHandlerSign = "_riggerHandlerSign";
        return Handler;
    }());
    riggerIOC.Handler = Handler;
})(riggerIOC || (riggerIOC = {}));

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    function startCoroutine(caller, method) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, method.apply(caller, args)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    riggerIOC.startCoroutine = startCoroutine;
    /**
     * 等下一帧，注意，这里的帧是指浏览器的帧（一般为4MS），而非游戏帧
     */
    function waitForNextFrame() {
        return new Promise(function (resolve) {
            setTimeout(resolve, 0);
        });
    }
    riggerIOC.waitForNextFrame = waitForNextFrame;
    function waitForSeconds(ms, conditinHandler, args) {
        if (args === void 0) { args = []; }
        var promise;
        if (!conditinHandler) {
            promise = new Promise(function (resolve) {
                setTimeout(resolve, ms);
            });
        }
        else {
            var ret = void 0;
            if (conditinHandler instanceof riggerIOC.Handler) {
                ret = conditinHandler.runWith(args);
            }
            else {
                ret = conditinHandler();
            }
            if (ret) {
                promise = new Promise(function (resolve) {
                    setTimeout(resolve, ms);
                });
            }
            else {
                promise = promise = new Promise(function (resolve) {
                    resolve();
                });
            }
        }
        return promise;
    }
    riggerIOC.waitForSeconds = waitForSeconds;
    /**
     * 等待命令执行完成
     * @param waitable
     */
    function waitFor(waitable) {
        return new Promise(function (resolve, reject) {
            if (waitable.isDone()) {
                resolve(waitable.getResult());
                waitable.reset();
            }
            else if (waitable.isCanceled()) {
                reject(waitable.getReason());
                waitable.reset();
            }
            else {
                waitable.setDoneCallback(resolve);
                waitable.setCancelCallback(reject);
            }
        });
    }
    riggerIOC.waitFor = waitFor;
})(riggerIOC || (riggerIOC = {}));


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
* 顺序执行器
*/
/// 
var riggerIOC;
(function (riggerIOC) {
    var TaskExecutor = /** @class */ (function () {
        function TaskExecutor() {
            /**
             * 所有需要执行的任务
             */
            this.mTasks = [];
            /**
             * 每一个任务执行后的回调
             */
            this.mSingleHandlers = [];
            this.mSingleHandlerArgs = [];
            /**
             * 每一个任务被取消后的回调
             */
            this.mSingleCancelHandlers = [];
            this.mSingleCancelHandlerArgs = [];
            /**
             * 所有任务执行完成后的回调
             */
            this.mCompleteHandler = null;
            this.mCompleteHandlerArgs = [];
            /**
             * 所有任务取消完成后的回调
             */
            this.mCancelHandler = null;
            this.mCancelHandlerArgs = [];
            /**
             * 当前正在执行的任务的游标
             */
            this.mCursor = -1;
            /**
             * 异步执行任务时的同步锁(保证所有任务执行完成后才会调用总的回调)
             */
            this.syncLock = null;
            /**
             * 异步执行任务时的计时器列表，用于保证每个任务之间的间隔
             */
            this.timers = null;
        }
        Object.defineProperty(TaskExecutor, "pool", {
            get: function () {
                if (!this.mPool)
                    this.mPool = new riggerIOC.Pool();
                return this.mPool;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 创建一个实例
        */
        TaskExecutor.create = function () {
            return TaskExecutor.pool.getItemByClass(TaskExecutor._sign, TaskExecutor);
        };
        Object.defineProperty(TaskExecutor.prototype, "isRunning", {
            /**
             * 是否正在执行任务
             */
            get: function () {
                return this.mCursor >= 0 || this.syncLock != null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 重置
         */
        TaskExecutor.prototype.reset = function () {
            this.dispose();
            return this;
        };
        /**
         * 回收
        */
        TaskExecutor.prototype.recover = function () {
            this.reset();
            TaskExecutor.pool.recover(TaskExecutor._sign, this);
        };
        /**
         * 执行任务，如果已经有任务正在执行，则会先打断之前的任务
         * @param ifSingleCallback
         */
        TaskExecutor.prototype.execute = function () {
            return __awaiter(this, void 0, void 0, function () {
                var executors, singleArgs, singleHandlers, cancelHandlers, cancelArgs, canceled, cancelReason, ret, reason_1, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!this.isRunning) return [3 /*break*/, 7];
                            executors = this.mTasks;
                            singleArgs = this.mSingleHandlerArgs;
                            singleHandlers = this.mSingleHandlers;
                            cancelHandlers = this.mSingleCancelHandlers;
                            cancelArgs = this.mSingleCancelHandlerArgs;
                            this.mCursor = 0;
                            canceled = false;
                            cancelReason = null;
                            _a.label = 1;
                        case 1:
                            if (!(this.mCursor < executors.length)) return [3 /*break*/, 6];
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, executors[this.mCursor].wait()];
                        case 3:
                            ret = _a.sent();
                            singleHandlers[this.mCursor]
                                && singleHandlers[this.mCursor].runWith([].concat(singleArgs[this.mCursor], ret));
                            return [3 /*break*/, 5];
                        case 4:
                            reason_1 = _a.sent();
                            canceled = true;
                            cancelReason = reason_1;
                            cancelHandlers[this.mCursor]
                                && cancelHandlers[this.mCursor].runWith([].concat(cancelArgs[this.mCursor], reason_1));
                            return [3 /*break*/, 6];
                        case 5:
                            ++this.mCursor;
                            return [3 /*break*/, 1];
                        case 6:
                            // 执行后面未执行任务的取消回调
                            if (canceled) {
                                for (i = this.mCursor + 1; i < this.mSingleCancelHandlers.length; ++i) {
                                    this.mSingleCancelHandlers[i]
                                        && this.mSingleCancelHandlers[i].runWith([].concat(this.mSingleCancelHandlerArgs[i], cancelReason));
                                }
                                this.mCancelHandler
                                    && this.mCancelHandler.runWith([].concat(this.mCancelHandlerArgs, cancelReason));
                            }
                            else {
                                this.mCompleteHandler && this.mCompleteHandler.runWith(this.mCompleteHandlerArgs);
                            }
                            // 游标归位
                            this.mCursor = -1;
                            return [3 /*break*/, 9];
                        case 7:
                            this.cancel();
                            return [4 /*yield*/, this.execute()];
                        case 8:
                            _a.sent();
                            _a.label = 9;
                        case 9: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * 异步执行
        */
        TaskExecutor.prototype.executeAsync = function (interval) {
            if (interval === void 0) { interval = null; }
            return __awaiter(this, void 0, void 0, function () {
                var totalWait, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!this.isRunning) return [3 /*break*/, 5];
                            if (interval == null || interval == undefined || interval < 0)
                                interval = 0;
                            this.syncLock = new riggerIOC.TaskExecutorLock(this.mTasks.length);
                            totalWait = this.syncLock.wait();
                            this.mCursor = 0;
                            for (; this.mCursor < this.mTasks.length; ++this.mCursor) {
                                this.executeSingle(this.mCursor, this.mCursor * interval);
                                // ++realTaskNum;
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, totalWait];
                        case 2:
                            _a.sent();
                            this.mCompleteHandler && this.mCompleteHandler.runWith(this.mCompleteHandlerArgs);
                            return [3 /*break*/, 4];
                        case 3:
                            error_1 = _a.sent();
                            this.mCancelHandler && this.mCancelHandler.runWith(this.mCancelHandlerArgs);
                            return [3 /*break*/, 4];
                        case 4:
                            // 清除计时器
                            this.clearTimer();
                            this.syncLock.dispose();
                            this.syncLock = null;
                            this.mCursor = -1;
                            return [3 /*break*/, 7];
                        case 5:
                            this.cancel();
                            return [4 /*yield*/, this.executeAsync(interval)];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         *
         * @param ifTotalCallback
         * 如果没有任务正在执行，则调用此接口没有任何效果
         */
        TaskExecutor.prototype.cancel = function (reason) {
            if (reason === void 0) { reason = null; }
            if (!this.isRunning)
                return;
            if (this.syncLock) {
                for (var i = 0; i < this.mTasks.length; ++i) {
                    this.mTasks[i].cancel(reason);
                }
                if (this.timers) {
                    for (var k in this.timers) {
                        this.timers[k].cancel(reason);
                    }
                    this.timers = null;
                }
            }
            else {
                this.mTasks[this.mCursor].cancel(reason);
            }
            return this;
        };
        /**
         * 析构函数，释放所有资源
         * 析构之前会先调用一次cancel(),打断所有正在执行的任务
        */
        TaskExecutor.prototype.dispose = function () {
            this.cancel();
            this.mCompleteHandler && this.mCompleteHandler.recover();
            this.mCompleteHandler = null;
            this.mCompleteHandlerArgs = [];
            this.mCancelHandler && this.mCancelHandler.recover();
            this.mCancelHandler = null;
            this.mCancelHandlerArgs = [];
            // 回收
            this.mTasks.forEach(function (exe) { return exe.dispose(); });
            this.mTasks = [];
            this.mSingleHandlers.forEach(function (handler) { return handler.recover(); });
            this.mSingleHandlers = [];
            this.mSingleHandlerArgs = [];
            this.mSingleCancelHandlers.forEach(function (Handler) { return Handler.recover(); });
            this.mSingleCancelHandlers = [];
            this.mSingleCancelHandlerArgs = [];
            this.syncLock && this.syncLock.dispose();
            this.syncLock = null;
            this.clearTimer();
        };
        /**
         *
         * @param waitable
         * @param completeHandler
         * @param args
         * @param cancelHandler
         * @param cancelArgs
         */
        TaskExecutor.prototype.add = function (waitable, completeHandler, args, cancelHandler, cancelArgs) {
            if (completeHandler === void 0) { completeHandler = null; }
            if (args === void 0) { args = []; }
            if (cancelHandler === void 0) { cancelHandler = null; }
            if (cancelArgs === void 0) { cancelArgs = []; }
            this.mTasks.push(waitable);
            this.mSingleHandlers.push(completeHandler);
            this.mSingleHandlerArgs.push(args);
            this.mSingleCancelHandlers.push(cancelHandler);
            this.mSingleCancelHandlerArgs.push(cancelArgs);
            return this;
        };
        /**
         * 设置完成时的回调，此回调是在所有执行队列都执行完成后才会回调
         * @param handler 回调
         * @param args 参数
         */
        TaskExecutor.prototype.setCompleteHandler = function (handler, args) {
            if (args === void 0) { args = []; }
            this.mCompleteHandler && this.mCompleteHandler.recover();
            this.mCompleteHandler = handler;
            this.mCompleteHandlerArgs = args;
            return this;
        };
        /**
         * 设置取消时的回调
         * @param handler
         * @param args
         */
        TaskExecutor.prototype.setCancelHandler = function (handler, args) {
            if (args === void 0) { args = []; }
            this.mCancelHandler && this.mCancelHandler.recover();
            this.mCancelHandler = handler;
            this.mCancelHandlerArgs = args;
            return this;
        };
        TaskExecutor.prototype.executeSingle = function (idx, delay) {
            return __awaiter(this, void 0, void 0, function () {
                var cancel, cancelArgs, timer, reason_2, exe, handler, args, ret, reason_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            cancel = this.mSingleCancelHandlers[idx];
                            cancelArgs = this.mSingleCancelHandlerArgs[idx];
                            if (!(delay > 0)) return [3 /*break*/, 4];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            timer = this.addTimer(idx);
                            return [4 /*yield*/, timer.forMSeconds(delay).wait()];
                        case 2:
                            _a.sent();
                            timer = null;
                            return [3 /*break*/, 4];
                        case 3:
                            reason_2 = _a.sent();
                            cancel.runWith([].concat(cancelArgs, reason_2));
                            this.syncLock.cancel();
                            return [2 /*return*/];
                        case 4:
                            if (idx < 0 || idx >= this.mTasks.length)
                                return [2 /*return*/];
                            exe = this.mTasks[idx];
                            handler = this.mSingleHandlers[idx];
                            args = this.mSingleCancelHandlerArgs[idx];
                            _a.label = 5;
                        case 5:
                            _a.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, exe.wait()];
                        case 6:
                            ret = _a.sent();
                            handler && handler.runWith([].concat(args, ret));
                            this.syncLock.done();
                            return [3 /*break*/, 8];
                        case 7:
                            reason_3 = _a.sent();
                            cancel && cancel.runWith([].concat(cancelArgs, reason_3));
                            this.syncLock.cancel();
                            return [3 /*break*/, 8];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        };
        TaskExecutor.prototype.addTimer = function (idx) {
            var timer = new riggerIOC.WaitForTime();
            if (!this.timers)
                this.timers = {};
            this.timers[idx] = timer;
            return timer;
        };
        TaskExecutor.prototype.clearTimer = function () {
            if (!this.timers)
                return;
            for (var k in this.timers) {
                // console.log("k in timer:" + k);
                this.timers[k].dispose();
                this.timers[k] = null;
                delete this.timers[k];
            }
            this.timers = null;
        };
        TaskExecutor._sign = "_sign_sequent_executor";
        return TaskExecutor;
    }());
    riggerIOC.TaskExecutor = TaskExecutor;
})(riggerIOC || (riggerIOC = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* 任务执行器的并行锁
* 辅助确保所有任务并行执行时，都执行完毕或被打断
*/
var riggerIOC;
(function (riggerIOC) {
    var TaskExecutorLock = /** @class */ (function (_super) {
        __extends(TaskExecutorLock, _super);
        function TaskExecutorLock(totalNum) {
            var _this = _super.call(this) || this;
            _this.totalTaskNum = 0;
            _this.doneNum = 0;
            _this.canceledNum = 0;
            _this.totalTaskNum = totalNum;
            _this.doneNum = 0;
            _this.canceledNum = 0;
            return _this;
        }
        TaskExecutorLock.prototype.adjustTotalNum = function (num) {
            this.totalTaskNum = num;
            this.check();
        };
        TaskExecutorLock.prototype.done = function () {
            ++this.doneNum;
            this.check();
        };
        TaskExecutorLock.prototype.cancel = function () {
            ++this.canceledNum;
            this.check();
        };
        TaskExecutorLock.prototype.check = function () {
            if (this.doneNum + this.canceledNum >= this.totalTaskNum) {
                if (this.canceledNum > 0) {
                    _super.prototype.cancel.call(this);
                }
                else {
                    _super.prototype.done.call(this);
                }
            }
        };
        return TaskExecutorLock;
    }(riggerIOC.BaseWaitable));
    riggerIOC.TaskExecutorLock = TaskExecutorLock;
})(riggerIOC || (riggerIOC = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* 一个可以等待的任务基类
*/
var riggerIOC;
(function (riggerIOC) {
    var WaitableTask = /** @class */ (function (_super) {
        __extends(WaitableTask, _super);
        function WaitableTask(content) {
            if (content === void 0) { content = null; }
            var _this = _super.call(this) || this;
            _this.mContent = null;
            _this.setContent(content);
            return _this;
        }
        WaitableTask.prototype.dispose = function () {
            this.mContent = null;
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(WaitableTask.prototype, "content", {
            /**
             * 获取任务内容
             */
            get: function () {
                return this.mContent;
            },
            /**
             * 设置任务内容
             */
            set: function (content) {
                this.setContent(content);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 设置任务内容
         */
        WaitableTask.prototype.setContent = function (content) {
            this.mContent = content;
            return this;
        };
        return WaitableTask;
    }(riggerIOC.BaseWaitable));
    riggerIOC.WaitableTask = WaitableTask;
})(riggerIOC || (riggerIOC = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* name
*/
var riggerIOC;
(function (riggerIOC) {
    var WaitForTime = /** @class */ (function (_super) {
        __extends(WaitForTime, _super);
        function WaitForTime() {
            var _this = _super.call(this) || this;
            _this.waitingMSeconds = null;
            _this.timerId = null;
            return _this;
        }
        /**
         * 设置要等待的秒数，并开始计时
         * 如果未设置任何时间就开始等待，则会永远等待直到被打断(WaitForTime.cancel())
         * @param seconds
         */
        WaitForTime.prototype.forSeconds = function (seconds, immediately) {
            if (immediately === void 0) { immediately = true; }
            return this.forMSeconds(seconds * 1000, immediately);
        };
        /**
         * 设置要等待的毫秒数, 并开始计时
         * 如果未设置任何时间就开始等待，则会永远等待直到被打断(WaitForTime.cancel())
         * @param mSeconds
         */
        WaitForTime.prototype.forMSeconds = function (mSeconds, immediately) {
            if (immediately === void 0) { immediately = true; }
            if (this.timerId !== null)
                return;
            if (immediately) {
                this.waitingMSeconds = null;
                var obj_1 = this;
                this.timerId = setTimeout(function () {
                    obj_1.timerId = null;
                    obj_1.done();
                    obj_1 = null;
                }, mSeconds);
            }
            else {
                this.waitingMSeconds = mSeconds;
            }
            return this;
        };
        /**
         * 等一帧
        */
        WaitForTime.prototype.forFrame = function () {
            return this.forMSeconds(0);
        };
        /**
         * 持续等待直到被打断
        */
        WaitForTime.prototype.forever = function () {
            if (this.timerId)
                clearTimeout(this.timerId);
            this.timerId = null;
            this.waitingMSeconds = null;
            return this;
        };
        /**
         * 开始等待，等待之前应该先设置好时间，
         * 如果未设置时间，则会一直等待，直到被打断，效果同:forever().wait()
        */
        WaitForTime.prototype.wait = function () {
            if (this.timerId == null && this.waitingMSeconds != null && !this.isWaitting()) {
                this.forMSeconds(this.waitingMSeconds);
            }
            return _super.prototype.wait.call(this);
        };
        /**
         * 取消等待
         * @param reason
         */
        WaitForTime.prototype.cancel = function (reason) {
            this.waitingMSeconds = null;
            if (this.timerId !== null)
                clearTimeout(this.timerId);
            this.timerId = null;
            _super.prototype.cancel.call(this, reason);
        };
        return WaitForTime;
    }(riggerIOC.BaseWaitable));
    riggerIOC.WaitForTime = WaitForTime;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var Event = /** @class */ (function () {
        function Event(mgr) {
            this.listenerManager = mgr;
        }
        Event.prototype.stop = function () {
            this.listenerManager && this.listenerManager.stop();
        };
        return Event;
    }());
    riggerIOC.Event = Event;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var EventDispatcher = /** @class */ (function () {
        function EventDispatcher() {
            this.eventsMap = {}; //{key:[]}
        }
        EventDispatcher.prototype.dispatch = function (eventName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var listenerMgr = this.eventsMap[eventName];
            if (!listenerMgr)
                return;
            var e = new riggerIOC.Event(listenerMgr);
            listenerMgr.execute.apply(listenerMgr, [e].concat(args));
        };
        EventDispatcher.prototype.on = function (eventName, caller, method) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            var listenerMgr = this.eventsMap[eventName];
            if (!listenerMgr)
                listenerMgr = this.eventsMap[eventName] = new riggerIOC.ListenerManager();
            return listenerMgr.on(caller, method, args);
        };
        EventDispatcher.prototype.off = function (eventName, caller, method) {
            var listenerMgr = this.eventsMap[eventName];
            if (!listenerMgr)
                return;
            return listenerMgr.off(caller, method);
        };
        EventDispatcher.prototype.dispose = function () {
            this.clear();
            this.eventsMap = null;
        };
        EventDispatcher.prototype.clear = function () {
            for (var k in this.eventsMap) {
                this.eventsMap[k].dispose();
                delete this.eventsMap[k];
            }
        };
        return EventDispatcher;
    }());
    riggerIOC.EventDispatcher = EventDispatcher;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var Signal = /** @class */ (function () {
        function Signal() {
        }
        Signal.prototype.dispose = function () {
            this.listenerMgr && this.listenerMgr.dispose();
            this.listenerMgr = null;
        };
        /**
         * 派发信号
         * @param arg
         */
        Signal.prototype.dispatch = function (arg) {
            if (this.listenerMgr)
                this.listenerMgr.execute(arg);
        };
        /**
         * 注册回调
         * @param caller
         * @param method
         * @param args
         */
        Signal.prototype.on = function (caller, method) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            this.makeSureListenerManager();
            this.listenerMgr.on(caller, method, args, false);
        };
        /**
         * 注册一次性回调
         * @param caller
         * @param method
         * @param args
         */
        Signal.prototype.once = function (caller, method) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            this.makeSureListenerManager();
            this.listenerMgr.on(caller, method, args, true);
        };
        /**
         * 取消回调
         * @param caller
         * @param method
         */
        Signal.prototype.off = function (caller, method) {
            if (this.listenerMgr)
                this.listenerMgr.off(caller, method);
        };
        /**
         * 保证ListenerManager可用
         */
        Signal.prototype.makeSureListenerManager = function () {
            if (!this.listenerMgr)
                this.listenerMgr = new riggerIOC.ListenerManager();
        };
        return Signal;
    }());
    riggerIOC.Signal = Signal;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var CommandBinder = /** @class */ (function () {
        function CommandBinder() {
        }
        return CommandBinder;
    }());
    riggerIOC.CommandBinder = CommandBinder;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
 * 绑定信息类
 */
var riggerIOC;
(function (riggerIOC) {
    var CommandBindInfo = /** @class */ (function () {
        function CommandBindInfo() {
        }
        return CommandBindInfo;
    }());
    riggerIOC.CommandBindInfo = CommandBindInfo;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
 * 注入绑定器类
 */
var riggerIOC;
(function (riggerIOC) {
    var InjectionBinder = /** @class */ (function () {
        function InjectionBinder() {
            this.registerKey = "_register_key";
        }
        Object.defineProperty(InjectionBinder, "instance", {
            get: function () {
                if (!InjectionBinder.mInstance) {
                    InjectionBinder.mInstance = new InjectionBinder();
                }
                return InjectionBinder.mInstance;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 绑定一个类,类不会重复绑定，如果已经存在绑定信息，则仅仅返回原来的绑定信息
         *
         * @param ctr 要绑定类的构造函数,推荐绑定抽象类
         * @return 返回对应的绑定信息
         */
        InjectionBinder.prototype.bind = function (cls) {
            // console.log("bind");
            // 查找是否已经有绑定过了
            var info = this.findBindInfo(cls);
            if (!info) {
                info = new riggerIOC.InjectionBindInfo(cls);
                if (!this.bindedArray)
                    this.bindedArray = [];
                this.bindedArray.push(info);
            }
            return info;
        };
        InjectionBinder.prototype.registerInjection = function (target, attName) {
            var arr = target[this.registerKey];
            if (!arr)
                arr = target[this.registerKey] = [];
            arr.push(attName);
        };
        /**
         * 进行注入
         * @param obj
         */
        InjectionBinder.prototype.inject = function (obj) {
            var prototype = obj["__proto__"];
            var arr = prototype[this.registerKey];
            if (!arr || arr.length <= 0)
                return;
            var len = arr.length;
            for (var i = 0; i < len; ++i) {
                obj[arr[i]];
            }
        };
        /**
         * 解绑
         * @param cls
         */
        InjectionBinder.prototype.unbind = function (cls) {
            // console.log("unbind");
            this.disposeBindInfo(cls);
        };
        /**
         * 从绑定列表中找到指定的绑定信息
         * @param ctr 指定的构造函数，是绑定信息的键
         */
        InjectionBinder.prototype.findBindInfo = function (ctr) {
            if (!ctr)
                return null;
            if (!this.bindedArray)
                return null;
            var info;
            var arr = this.bindedArray;
            var len = arr.length;
            for (var i = 0; i < len; i++) {
                info = arr[i];
                if (info.cls === ctr)
                    return info;
            }
            return null;
        };
        InjectionBinder.prototype.disposeBindInfo = function (cls) {
            if (!cls)
                return;
            var arr = this.bindedArray;
            if (!arr)
                return;
            var len = arr.length;
            if (len <= 0)
                return;
            var temp = [];
            var info;
            for (var i = 0; i < len; ++i) {
                info = arr[i];
                if (info.cls !== cls) {
                    info.dispose();
                    temp.push(info);
                }
            }
            this.bindedArray = temp;
        };
        return InjectionBinder;
    }());
    riggerIOC.InjectionBinder = InjectionBinder;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var InjectionBindInfo = /** @class */ (function () {
        function InjectionBindInfo(ctr) {
            this.cls = null;
            this.mBindCls = null;
            this.isSingleton = false;
            /**
             * 实例，只有当为单例模式时才会给此字段赋值
             */
            this.instance = null;
            this.cls = ctr;
        }
        Object.defineProperty(InjectionBindInfo.prototype, "realClass", {
            get: function () {
                if (this.mBindCls)
                    return this.mBindCls;
                return this.cls;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InjectionBindInfo.prototype, "hasInstance", {
            /**
             * 是否注入类的实例
             */
            get: function () {
                return !!this.instance;
            },
            enumerable: true,
            configurable: true
        });
        InjectionBindInfo.prototype.dispose = function () {
            this.cls = null;
            this.mBindCls = null;
            this.instance = null;
        };
        /**
         * 绑定到目标类
         * @param ctr 目标类的构造函数
         */
        InjectionBindInfo.prototype.to = function (ctr) {
            // 不能绑定到自身
            if (ctr === this.cls)
                throw new Error("can not bind to self.");
            this.mBindCls = ctr;
            return this;
        };
        /**
         * 绑定到值，此时会自动进行单例绑定
         * @param value
         */
        InjectionBindInfo.prototype.toValue = function (value) {
            this.toSingleton();
            this.instance = value;
            return this;
        };
        /**
         * 将绑定设置为单例模式
         */
        InjectionBindInfo.prototype.toSingleton = function () {
            this.isSingleton = true;
            return this;
        };
        /**
         * 获取实例
         */
        InjectionBindInfo.prototype.getInstance = function () {
            if (this.instance)
                return this.instance;
            var inst = new (this.realClass)();
            // let cls = this.realClass
            // if (this.mBindCls) {
            // 	inst = new this.mBindCls();
            // }else if(this.cls){
            // 	inst = new this.cls();
            // }
            if (this.isSingleton) {
                this.instance = inst;
            }
            return inst;
        };
        return InjectionBindInfo;
    }());
    riggerIOC.InjectionBindInfo = InjectionBindInfo;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    function inject(ctr) {
        return function (target, attrName, descripter) {
            // console.log(`in inject, attr:${attrName}, ctr:${ctr}`);
            if (descripter) {
                doInjectGetterSetter(ctr, target, attrName, descripter);
            }
            else {
                doInjectAttr(ctr, target, attrName);
            }
        };
    }
    riggerIOC.inject = inject;
    /**
     * 注入的属性的键
     */
    var injectionAttrKey = "$$";
    /**
     * 对getter/setter方法进行注入
     * @param key
     * @param taget
     * @param attrName
     * @param descripter
     */
    function doInjectGetterSetter(key, target, attrName, descripter) {
        var info = riggerIOC.InjectionBinder.instance.bind(key);
        var k = injectionAttrKey + attrName;
        // 注册需要注入的属性名/存取器器名
        riggerIOC.InjectionBinder.instance.registerInjection(target, attrName);
        descripter.get = function () {
            var v = this[k];
            if (v === null || v === undefined) {
                v = this[k] = info.getInstance();
                // info = null;
            }
            return v;
        };
        descripter.set = function (v) {
            this[k] = v;
        };
    }
    /**
     * 对成员属性进行注入
     * @param key 构造函数
     * @param target 原型对象
     * @param attrName 属性名
     */
    function doInjectAttr(key, target, attrName) {
        var info = riggerIOC.InjectionBinder.instance.bind(key);
        var k = injectionAttrKey + attrName;
        // 注册需要注入的属性名/存取器器名
        riggerIOC.InjectionBinder.instance.registerInjection(target, attrName);
        Object.defineProperty(target, attrName, {
            get: function () {
                var v = this[k];
                if (v === null || v === undefined) {
                    v = this[k] = info.getInstance();
                    // info = null;
                }
                return v;
            },
            set: function (v) {
                this[k] = v;
            },
            enumerable: true,
            configurable: true
        });
    }
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* Mediator绑定器
*/
var riggerIOC;
(function (riggerIOC) {
    var MediationBinder = /** @class */ (function () {
        function MediationBinder() {
        }
        /**
         *
         *
         * @param cls
         */
        MediationBinder.prototype.bind = function (cls) {
            if (!this.mInfos)
                this.mInfos = [];
            var info = this.findBindInfo(cls);
            if (!info) {
                info = new riggerIOC.MediationBindInfo(cls);
                this.mInfos.push(info);
            }
            return info;
        };
        /**
         * 根据视图信息获取其绑定的Mediator实例
         * @param viewCls 视图类的构造函数
         * @param view 视图的实例
         */
        MediationBinder.prototype.createAndAttach = function (viewCls, view) {
            var info = this.findBindInfo(viewCls);
            if (!info)
                return null;
            if (!info.bindMediatorConstructor)
                return null;
            // 注入VIEW
            var injectionInfo = riggerIOC.InjectionBinder.instance.bind(viewCls);
            if (!injectionInfo.hasInstance) {
                injectionInfo.toValue(view);
            }
            var inst = riggerIOC.InjectionBinder.instance.bind(info.bindMediatorConstructor).getInstance();
            riggerIOC.InjectionBinder.instance.inject(inst);
            // 取消绑定
            injectionInfo.toValue(null);
            this.addBindTuple(view, inst);
            return inst;
        };
        /**
         * 将视图与mediator分离
         * @param view
         * @param mediator
         */
        MediationBinder.prototype.detach = function (view, mediator) {
            var tuples = this.bindTuples;
            if (!tuples)
                return;
            var len = tuples.length;
            if (len <= 0)
                return;
            var temp = [];
            for (var i = 0; i < len; ++i) {
                if (tuples[i].view === view) {
                    tuples[i].dispose();
                }
                else {
                    temp.push(tuples[i]);
                }
            }
            this.bindTuples = temp;
        };
        /**
         * 获取已经和视图绑定的mediator实例
         * @param view
         */
        MediationBinder.prototype.getAttachedMediatorInstance = function (view) {
            var tuples = this.bindTuples;
            if (!tuples)
                return null;
            var len = tuples.length;
            if (len <= 0)
                return null;
            for (var i = 0; i < len; ++i) {
                if (tuples[i].view === view) {
                    return tuples[i].mediator;
                }
            }
            return null;
        };
        /**
         * 查找绑定信息
         * @param viewCls
         */
        MediationBinder.prototype.findBindInfo = function (viewCls) {
            var infos = this.mInfos;
            if (!infos || infos.length <= 0)
                return null;
            var len = infos.length;
            for (var i = 0; i < len; ++i) {
                if (viewCls === infos[i].viewConstructor)
                    return infos[i];
            }
            return null;
        };
        MediationBinder.prototype.addBindTuple = function (view, mediator) {
            if (!this.bindTuples)
                this.bindTuples = [];
            this.bindTuples.push(new riggerIOC.ViewMediatorTuple(view, mediator));
        };
        return MediationBinder;
    }());
    riggerIOC.MediationBinder = MediationBinder;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* Mediation的绑定信息
*/
var riggerIOC;
(function (riggerIOC) {
    var MediationBindInfo = /** @class */ (function () {
        function MediationBindInfo(cls) {
            this.mViewConstructor = cls;
        }
        Object.defineProperty(MediationBindInfo.prototype, "viewConstructor", {
            /**
             * 绑定的视图类构造函数
             */
            get: function () {
                return this.mViewConstructor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediationBindInfo.prototype, "bindMediatorConstructor", {
            /**
             * 与视图绑定的中介类
             */
            get: function () {
                return this.mBindMediatorConstructor;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 将视图绑定到中介类
         * @param mediatorCls
         */
        MediationBindInfo.prototype.to = function (mediatorCls) {
            this.mBindMediatorConstructor = mediatorCls;
            return this;
        };
        return MediationBindInfo;
    }());
    riggerIOC.MediationBindInfo = MediationBindInfo;
})(riggerIOC || (riggerIOC = {}));

/*
* Copyright 2018 Yang Wu.
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*		Unless required by applicable law or agreed to in writing, software
*		distributed under the License is distributed on an "AS IS" BASIS,
*		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*		See the License for the specific language governing permissions and
*		limitations under the License.
*/
/**
* View和Mediator的绑定元组
*/
var riggerIOC;
(function (riggerIOC) {
    var ViewMediatorTuple = /** @class */ (function () {
        function ViewMediatorTuple(view, mediator) {
            this.view = view;
            this.mediator = mediator;
        }
        ViewMediatorTuple.prototype.dispose = function () {
            this.view = null;
            this.mediator = null;
        };
        return ViewMediatorTuple;
    }());
    riggerIOC.ViewMediatorTuple = ViewMediatorTuple;
})(riggerIOC || (riggerIOC = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
///<reference path = "../../coroutine/BaseWaitable.ts" />
var riggerIOC;
(function (riggerIOC) {
    var Command = /** @class */ (function (_super) {
        __extends(Command, _super);
        function Command() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Command;
    }(riggerIOC.BaseWaitable));
    riggerIOC.Command = Command;
})(riggerIOC || (riggerIOC = {}));

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* name
*/
var riggerIOC;
(function (riggerIOC) {
    /**
     * 模块启动完成的命令
     */
    var ModuleDoneCommand = /** @class */ (function (_super) {
        __extends(ModuleDoneCommand, _super);
        function ModuleDoneCommand() {
            return _super.call(this) || this;
        }
        ModuleDoneCommand.prototype.execute = function () {
            this.moduleContext && this.moduleContext.done();
            this.done();
        };
        ModuleDoneCommand.prototype.setModuleContext = function (moduleContext) {
            this.moduleContext = moduleContext;
        };
        return ModuleDoneCommand;
    }(riggerIOC.Command));
    riggerIOC.ModuleDoneCommand = ModuleDoneCommand;
})(riggerIOC || (riggerIOC = {}));

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var ApplicationContext = /** @class */ (function () {
        function ApplicationContext() {
            // this.injectionBinder = InjectionBinder.instance;
            // 注入自身
            // this.injectionBinder.bind(ApplicationContext).toValue(this);
            // 绑定命令绑定器，默认绑定为SignalCommandBinder
            this.bindCommandBinder();
            this.bindMediationBinder();
            // 绑定用户的注入
            this.bindInjections();
            // 绑定用户的命令
            this.bindCommands();
            this.modules = [];
            // 注册模块
            this.registerModuleContexts();
            // 实例化所有的模块
            this.initializeModuleContexts();
        }
        Object.defineProperty(ApplicationContext.prototype, "injectionBinder", {
            get: function () {
                return riggerIOC.InjectionBinder.instance;
            },
            enumerable: true,
            configurable: true
        });
        ApplicationContext.prototype.dispose = function () {
            for (var i = 0; i < this.modules.length; ++i) {
                this.injectionBinder.unbind(this.modules[i]);
            }
            // this.injectionBinder = null;
            this.modules = null;
            this.commandBinder = null;
        };
        ApplicationContext.prototype.getInjectionBinder = function () {
            return this.injectionBinder;
        };
        ApplicationContext.prototype.getCommandBinder = function () {
            return this.commandBinder;
        };
        ApplicationContext.prototype.getMediationBinder = function () {
            return this.mediationBinder;
        };
        ApplicationContext.prototype.initializeModuleContexts = function () {
            return __awaiter(this, void 0, void 0, function () {
                var m, i, info;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < this.modules.length)) return [3 /*break*/, 4];
                            info = this.injectionBinder.bind(this.modules[i]);
                            m = new info.realClass(this);
                            info.toValue(m);
                            m.start();
                            return [4 /*yield*/, m.wait()];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            ++i;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        ApplicationContext.prototype.addModuleContext = function (contextCls) {
            this.modules.push(contextCls);
            return this;
        };
        ApplicationContext.prototype.bindCommandBinder = function () {
            // 绑定 命令绑定器，并设置为单例
            this.injectionBinder.bind(riggerIOC.CommandBinder).to(riggerIOC.SignalCommandBinder).toSingleton();
        };
        ApplicationContext.prototype.bindMediationBinder = function () {
            this.injectionBinder.bind(riggerIOC.MediationBinder).toSingleton();
        };
        __decorate([
            riggerIOC.inject(riggerIOC.CommandBinder),
            __metadata("design:type", riggerIOC.CommandBinder)
        ], ApplicationContext.prototype, "commandBinder", void 0);
        __decorate([
            riggerIOC.inject(riggerIOC.MediationBinder),
            __metadata("design:type", riggerIOC.MediationBinder)
        ], ApplicationContext.prototype, "mediationBinder", void 0);
        return ApplicationContext;
    }());
    riggerIOC.ApplicationContext = ApplicationContext;
})(riggerIOC || (riggerIOC = {}));


var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
///<reference path = "../../coroutine/BaseWaitable.ts" />
var riggerIOC;
(function (riggerIOC) {
    /**
     * 模块上下文
     * 模块上下文初始化（启动）完成后，需要通过以下语句显式（在onStart）通知：
     * 		this.doneCommand.execute()
     * 或
     * 		this.done()
    */
    var ModuleContext = /** @class */ (function (_super) {
        __extends(ModuleContext, _super);
        function ModuleContext(appContext) {
            var _this = _super.call(this) || this;
            _this.applicationContext = appContext;
            _this.doneCommand = new riggerIOC.ModuleDoneCommand();
            _this.doneCommand.setModuleContext(_this);
            _this.bindInjections();
            _this.bindCommands();
            _this.bindMediators();
            return _this;
        }
        ModuleContext.prototype.dispose = function () {
            this.applicationContext = null;
        };
        Object.defineProperty(ModuleContext.prototype, "injectionBinder", {
            get: function () {
                return this.getInjectionBinder();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModuleContext.prototype, "commandBinder", {
            get: function () {
                return this.getCommandBinder();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModuleContext.prototype, "mediationBinder", {
            get: function () {
                return this.getMediationBinder();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 获取注入绑定器
         */
        ModuleContext.prototype.getInjectionBinder = function () {
            return this.applicationContext.getInjectionBinder();
        };
        /**
         * 获取命令绑定器
         */
        ModuleContext.prototype.getCommandBinder = function () {
            return this.applicationContext.getCommandBinder();
        };
        ModuleContext.prototype.getMediationBinder = function () {
            return this.applicationContext.getMediationBinder();
        };
        ModuleContext.prototype.start = function () {
            _super.prototype.startTask.call(this);
            this.onStart();
        };
        return ModuleContext;
    }(riggerIOC.BaseWaitable));
    riggerIOC.ModuleContext = ModuleContext;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var Model = /** @class */ (function () {
        function Model() {
        }
        return Model;
    }());
    riggerIOC.Model = Model;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var Server = /** @class */ (function () {
        function Server() {
        }
        return Server;
    }());
    riggerIOC.Server = Server;
})(riggerIOC || (riggerIOC = {}));

/*
* Copyright 2018 Yang Wu.
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*		Unless required by applicable law or agreed to in writing, software
*		distributed under the License is distributed on an "AS IS" BASIS,
*		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*		See the License for the specific language governing permissions and
*		limitations under the License.
*/
/**
* 视图的中介类
*/
var riggerIOC;
(function (riggerIOC) {
    var Mediator = /** @class */ (function () {
        function Mediator() {
        }
        return Mediator;
    }());
    riggerIOC.Mediator = Mediator;
})(riggerIOC || (riggerIOC = {}));

/*
* Copyright 2018 Yang Wu.
*
*	Licensed under the Apache License, Version 2.0 (the "License");
*	you may not use this file except in compliance with the License.
*	You may obtain a copy of the License at
*
*		http://www.apache.org/licenses/LICENSE-2.0
*
*		Unless required by applicable law or agreed to in writing, software
*		distributed under the License is distributed on an "AS IS" BASIS,
*		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*		See the License for the specific language governing permissions and
*		limitations under the License.
*/
/**
* 视图抽象基类
*/
var riggerIOC;
(function (riggerIOC) {
    var View = /** @class */ (function () {
        function View() {
        }
        return View;
    }());
    riggerIOC.View = View;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var Pool = /** @class */ (function () {
        function Pool() {
            this.objectPool = {};
            this.objectPool = {};
        }
        /**
         * 根据对象类型标识字符，获取对象池。
         * @param sign 对象类型标识字符。
         * @return 对象池。
         */
        Pool.prototype.getPoolBySign = function (sign) {
            var arr = this.objectPool[sign];
            if (!arr) {
                this.objectPool[sign] = arr = [];
            }
            return arr;
        };
        /**
         * 清除对象池的对象。
         * @param sign 对象类型标识字符。
         */
        Pool.prototype.clearBySign = function (sign) {
            delete this.objectPool[sign];
        };
        /**
         * 将对象放到对应类型标识的对象池中。
         * @param sign 对象类型标识字符。
         * @param item 对象。
         */
        Pool.prototype.recover = function (sign, item) {
            var old = this.getPoolBySign(sign);
            old.push(item);
        };
        /**
         * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
         * <p>当对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。</p>
         * @param sign 对象类型标识字符。
         * @param cls 用于创建该类型对象的类。
         * @return 此类型标识的一个对象。
         */
        Pool.prototype.getItemByClass = function (sign, cls) {
            var obj = this.getItem(sign);
            if (obj)
                return obj;
            return new cls();
        };
        /**
         * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
         * <p>当对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。</p>
         * @param sign 对象类型标识字符。
         * @param createFun 用于创建该类型对象的方法。
         * @return 此类型标识的一个对象。
         */
        Pool.prototype.getItemByCreateFun = function (sign, createFun) {
            var obj = this.getItem(sign);
            if (obj)
                return obj;
            return createFun();
        };
        /**
         * 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
         * @param sign 对象类型标识字符。
         * @return 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
         */
        Pool.prototype.getItem = function (sign) {
            var pool = this.getPoolBySign(sign);
            if (pool.length <= 0)
                return null;
            return pool.pop();
        };
        return Pool;
    }());
    riggerIOC.Pool = Pool;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var ListenerManager = /** @class */ (function () {
        function ListenerManager() {
            this.stopped = false;
        }
        ListenerManager.prototype.dispose = function () {
            this.stopped = false;
            this.clear();
        };
        ListenerManager.prototype.on = function (caller, method, args, once) {
            if (once === void 0) { once = false; }
            if (!this.handlers)
                this.handlers = [];
            var handler = new riggerIOC.Handler(caller, method, args, once);
            this.handlers.push(handler);
            return handler;
        };
        /**
         * 解除回调
         * @param caller
         * @param method
         */
        ListenerManager.prototype.off = function (caller, method) {
            if (!this.handlers || this.handlers.length <= 0)
                return;
            var tempHandlers = [];
            for (var i = 0; i < this.handlers.length; i++) {
                var handler = this.handlers[i];
                if (handler.caller === caller && handler.method === method) {
                    handler.recover();
                    break;
                }
                else {
                    tempHandlers.push(handler);
                }
            }
            // 把剩下的放回
            ++i;
            for (; i < this.handlers.length; ++i) {
                tempHandlers.push(this.handlers[i]);
            }
            this.handlers = tempHandlers;
        };
        /**
         * 解除所有回调
         * @param caller
         * @param method
         */
        ListenerManager.prototype.offAll = function (caller, method) {
            if (!this.handlers || this.handlers.length <= 0)
                return;
            var temp = [];
            var handlers = this.handlers;
            var len = handlers.length;
            for (var i = 0; i < len; ++i) {
                if (caller !== handlers[i].caller || method !== handlers[i].method) {
                    temp.push(handlers[i]);
                }
                else {
                    handlers[i].recover();
                }
            }
            this.handlers = temp;
        };
        /**
         * 清除所有回调
         */
        ListenerManager.prototype.clear = function () {
            if (!this.handlers || this.handlers.length <= 0)
                return;
            for (var i = 0; i < this.handlers.length; i++) {
                var handler = this.handlers[i];
                handler.recover();
            }
            this.handlers = null;
        };
        ListenerManager.prototype.stop = function () {
            this.stopped = true;
        };
        ListenerManager.prototype.execute = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this.handlers || this.handlers.length <= 0)
                return;
            var handlers = this.handlers;
            var len = handlers.length;
            var handler;
            var temp = [];
            var i = 0;
            for (; i < len; ++i) {
                if (this.stopped)
                    break;
                handler = handlers[i];
                handler.runWith(args);
                if (handler.method) {
                    temp.push(handler);
                }
            }
            for (; i < len; ++i) {
                temp.push(handlers[i]);
            }
            this.stopped = false;
            this.handlers = temp;
            handler = null;
            handlers = null;
            temp = null;
        };
        return ListenerManager;
    }());
    riggerIOC.ListenerManager = ListenerManager;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var CommandBindTuple = /** @class */ (function () {
        function CommandBindTuple(cls) {
            this.ctr = cls;
            this.inst = null;
        }
        return CommandBindTuple;
    }());
    riggerIOC.CommandBindTuple = CommandBindTuple;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
/**
* 消息与命令的绑定器
* 一个消息可以同时绑定多个命令(即一个消息可以导致多个命令的执行)
* 但一个命令不能同时被绑定到多个消息
*/
var riggerIOC;
(function (riggerIOC) {
    var EventCommandBinder = /** @class */ (function () {
        function EventCommandBinder() {
        }
        /**
         * 绑定消息
         * @param msg
         */
        EventCommandBinder.prototype.bind = function (msg) {
            if (!this.commandsMap)
                this.commandsMap = {};
            var info = this.findBindInfo(msg);
            if (!info)
                return this.commandsMap[msg] = new riggerIOC.EventCommandBindInfo(msg);
            return info;
        };
        /**
         * 查找绑定消息
         * @param msg
         */
        EventCommandBinder.prototype.findBindInfo = function (msg) {
            var info = this.commandsMap[msg];
            if (info)
                return info;
            return null;
        };
        return EventCommandBinder;
    }());
    riggerIOC.EventCommandBinder = EventCommandBinder;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var EventCommandBindInfo = /** @class */ (function () {
        function EventCommandBindInfo(msg) {
            this.message = null;
            this.message = msg;
            this.bindTuples = [];
        }
        /**
         * 绑定到指定命令
         * @param cls
         */
        EventCommandBindInfo.prototype.to = function (cls) {
            var infos = this.bindTuples;
            var len = infos.length;
            var tuple;
            for (var i = 0; i < len; ++i) {
                tuple = infos[i];
                if (tuple.ctr === cls) {
                    return this;
                }
            }
            infos.push(new riggerIOC.CommandBindTuple(cls));
            return this;
        };
        EventCommandBindInfo.prototype.toValue = function (value) {
            // TODO 等待实现
            return this;
        };
        EventCommandBindInfo.prototype.once = function () {
            return this;
        };
        EventCommandBindInfo.prototype.inSequence = function () {
            return this;
        };
        /**
         * 将绑定设置为单例模式
         * ！！！对于Command而言，其总是单例的，此接口只是为了提醒使用者
         */
        EventCommandBindInfo.prototype.toSingleton = function () {
            throw new Error("command is always Singleton.");
        };
        return EventCommandBindInfo;
    }());
    riggerIOC.EventCommandBindInfo = EventCommandBindInfo;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var riggerIOC;
(function (riggerIOC) {
    var SignalCommandBinder = /** @class */ (function () {
        function SignalCommandBinder() {
        }
        /**
         * 绑定一个信号
         * 绑定后，信号将被注入为单例模式，并且同时会立即产生一个实例
         * @param cls
         */
        SignalCommandBinder.prototype.bind = function (cls) {
            // 将信号注入为单例,并返回对应的命令绑定信息
            return new riggerIOC.SignalCommandBindInfo(riggerIOC.InjectionBinder.instance.bind(cls).toSingleton().getInstance());
        };
        return SignalCommandBinder;
    }());
    riggerIOC.SignalCommandBinder = SignalCommandBinder;
})(riggerIOC || (riggerIOC = {}));

/*
 * Copyright 2018 Yang Wu.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 *		Unless required by applicable law or agreed to in writing, software
 *		distributed under the License is distributed on an "AS IS" BASIS,
 *		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *		See the License for the specific language governing permissions and
 *		limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * 信号与命令的绑定信息类
 */
var riggerIOC;
(function (riggerIOC) {
    var CommandInfo = /** @class */ (function () {
        function CommandInfo() {
        }
        return CommandInfo;
    }());
    var SignalCommandBindInfo = /** @class */ (function () {
        function SignalCommandBindInfo(signal) {
            this.commandsCls = [];
            this.bindSignal = signal;
            this.isOnce = false;
            this.isInSequence = false;
            signal.on(this, this.onSignal);
        }
        SignalCommandBindInfo.prototype.dispose = function () {
            this.bindSignal.off(this, this.onSignal);
            this.bindSignal.dispose();
            this.bindSignal = null;
            this.commandsCls = null;
        };
        /**
         * 将信号绑定到命令，可以重复执行以绑定到多个命令
         * @param cmdCls
         */
        SignalCommandBindInfo.prototype.to = function (cmdCls) {
            riggerIOC.InjectionBinder.instance.bind(cmdCls);
            this.commandsCls.push({ cls: cmdCls, inst: null });
            return this;
        };
        /**
         * 绑定到值，此时会自动进行单例绑定
         * @param value
         */
        SignalCommandBindInfo.prototype.toValue = function (value) {
            // this.toSingleton();
            // InjectionBinder.instance.bind(cmdCls);			
            this.commandsCls.push({ cls: null, inst: value });
            return this;
        };
        /**
         * 设置为一次性绑定
         */
        SignalCommandBindInfo.prototype.once = function () {
            this.isOnce = true;
            return this;
        };
        /**
         * 设置为顺序命令
         */
        SignalCommandBindInfo.prototype.inSequence = function () {
            this.isInSequence = true;
            return this;
        };
        SignalCommandBindInfo.prototype.onSignal = function (arg) {
            this.executeCommands(arg);
        };
        /**
         * 执行绑定的命令
         * @param arg
         */
        SignalCommandBindInfo.prototype.executeCommands = function (arg) {
            return __awaiter(this, void 0, void 0, function () {
                var i, cmd, cmdInfo;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < this.commandsCls.length)) return [3 /*break*/, 4];
                            cmd = void 0;
                            cmdInfo = this.commandsCls[i];
                            if (cmdInfo.inst) {
                                cmd = cmdInfo.inst;
                            }
                            else {
                                cmd = riggerIOC.InjectionBinder.instance.bind(cmdInfo.cls).getInstance();
                            }
                            cmd.execute(arg);
                            if (!this.isInSequence) return [3 /*break*/, 3];
                            return [4 /*yield*/, cmd.wait()];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            ++i;
                            return [3 /*break*/, 1];
                        case 4:
                            // 如果是一次性的，则释放
                            if (this.isOnce)
                                this.dispose();
                            return [2 /*return*/];
                    }
                });
            });
        };
        return SignalCommandBindInfo;
    }());
    riggerIOC.SignalCommandBindInfo = SignalCommandBindInfo;
})(riggerIOC || (riggerIOC = {}));
